import random
import math

# Step 1: Define cities and calculate distances
cities = [
    (0, 0), (1, 5), (5, 2), (6, 6),
    (8, 3), (7, 9), (2, 8), (3, 3)
]

num_cities = len(cities)

def distance(city1, city2):
    return math.sqrt((city1[0] - city2[0]) ** 2 + (city1[1] - city2[1]) ** 2)

# Create distance matrix
distance_matrix = []
for i in range(num_cities):
    row = []
    for j in range(num_cities):
        if i == j:
            row.append(float('inf'))
        else:
            row.append(distance(cities[i], cities[j]))
    distance_matrix.append(row)

# Step 2: Initialize parameters
num_ants = 10
num_iterations = 100
alpha = 1.0       # pheromone importance
beta = 5.0        # heuristic importance (1/distance)
rho = 0.5         # evaporation rate
Q = 100           # pheromone deposit factor

# Initialize pheromone matrix with 0.1
pheromone = []
for i in range(num_cities):
    pheromone.append([0.1] * num_cities)

def calculate_tour_length(tour):
    length = 0
    for i in range(len(tour) - 1):
        length += distance_matrix[tour[i]][tour[i+1]]
    length += distance_matrix[tour[-1]][tour[0]]  # return to start
    return length

def select_next_city(current_city, visited, pheromone, distance_matrix):
    probabilities = []
    denominator = 0

    for city in range(num_cities):
        if city not in visited:
            pheromone_val = pheromone[current_city][city] ** alpha
            heuristic_val = (1 / distance_matrix[current_city][city]) ** beta
            denominator += pheromone_val * heuristic_val

    for city in range(num_cities):
        if city in visited:
            probabilities.append(0)
        else:
            pheromone_val = pheromone[current_city][city] ** alpha
            heuristic_val = (1 / distance_matrix[current_city][city]) ** beta
            prob = (pheromone_val * heuristic_val) / denominator if denominator > 0 else 0
            probabilities.append(prob)

    # Roulette wheel selection
    r = random.random()
    cumulative = 0
    for i, prob in enumerate(probabilities):
        cumulative += prob
        if r <= cumulative:
            return i

def construct_solution(pheromone, distance_matrix):
    tour = []
    start = random.randint(0, num_cities - 1)
    tour.append(start)
    visited = set(tour)

    current_city = start
    while len(tour) < num_cities:
        next_city = select_next_city(current_city, visited, pheromone, distance_matrix)
        tour.append(next_city)
        visited.add(next_city)
        current_city = next_city

    return tour

def update_pheromones(pheromone, ants_tours, ants_lengths):
    # Evaporate pheromone
    for i in range(num_cities):
        for j in range(num_cities):
            pheromone[i][j] *= (1 - rho)

    # Deposit new pheromone based on tour quality
    for tour, length in zip(ants_tours, ants_lengths):
        deposit = Q / length
        for i in range(len(tour) - 1):
            pheromone[tour[i]][tour[i+1]] += deposit
            pheromone[tour[i+1]][tour[i]] += deposit
        # Add pheromone for return to start edge
        pheromone[tour[-1]][tour[0]] += deposit
        pheromone[tour[0]][tour[-1]] += deposit

# Main loop
best_tour = None
best_length = float('inf')

for iteration in range(num_iterations):
    ants_tours = []
    ants_lengths = []

    for _ in range(num_ants):
        tour = construct_solution(pheromone, distance_matrix)
        length = calculate_tour_length(tour)
        ants_tours.append(tour)
        ants_lengths.append(length)

        if length < best_length:
            best_length = length
            best_tour = tour

    update_pheromones(pheromone, ants_tours, ants_lengths)

print("Best tour found:", best_tour)
print("Best tour length:", best_length)
